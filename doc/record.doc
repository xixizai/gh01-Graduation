【github noxim里面的odd-even路由似乎也是最小路由。。为什么要分奇偶呢（知道是避免死锁的同时扩大路径多样性，但是是怎么做到的？）】
摘要
非规则计算早已经成为科学计算和社会计算的核心操作之一。随着时代的发展，单核 CPU 已经远远不能满足当前的计算需求，多核技术与众核技术应运而生，这为大规模并行计算的加速带来了新的可能。稀疏矩阵向量计算作为典型的非规则计算，将其封装为一个兼容多核以及众核平台的函数库可以给使用者带来极大的便利。
本文针对既有稀疏矩阵并行算法库缺乏对多种矩阵存储格式及多核以及众核体系结构支持的问题，提出了面向众核体系结构的稀疏矩阵算法库，主要工作为：
1)  设计了面向众核体系结构的稀疏矩阵算法库的整体架构。利用层次化的思想将整 体架构分为数据层、计算层和用户层三层，使得稀疏矩阵算法库拥有更加优秀的易扩展、 低耦合、便于维护等特性。
2)  提出了稀疏矩阵的存储数据结构和格式转换机制。数据管理功能要求数据具有易 插入和易删除的特点，而计算管理功能要求数据具有易访存的特点。针对这两种不同的 需求，本文分别基于链表和数组设计了两种稀疏矩阵的存储数据结构。本文实现了一个 较为成熟的稀疏矩阵存储格式转换机制，支持不同的矩阵格式之间的双向转换。
3)  针对多核以及众核体系结构，使用特定的技术对并行算法进行结合体系结构的优 化。首先使用一个适用于多核以及众核体系结构的共性的优化方式，改造算法中的循环 使循环之间没有数据依赖。在此基础上，利用 OpenMP 技术动态设计线程数量优化多核 平台上的并行算法；利用循环合并和编译器自动向量化的方法优化 MIC 上的并行算法；利用 C+CUDA 的编程方法结合带状任务划分策略优化 GPU 上的并行算法。
4)  对面向众核体系结构的稀疏矩阵算法库在不同的体系结构下进行功能正确性及性能测试。测试结果表明，面向众核体系结构的稀疏矩阵算法库在不同平台上能够实现基本功能，拥有优良的可扩展性。与串行算法相比，稀疏矩阵算法库在不同的众核平台 上获得了很好的性能提升，其中在 GPU 上的加速比高达 26.92。

关键词：稀疏矩阵向量计算；众核技术；MIC；GPU






Abstract
非规则计算早已经成为科学计算和社会计算的核心操作之一。随着时代的发展，单核 CPU 已经远远不能满足当前的计算需求，多核技术与众核技术应运而生，这为大规模并行计算的加速带来了新的可能。稀疏矩阵向量计算作为典型的非规则计算，将其封装为一个兼容多核以及众核平台的函数库可以给使用者带来极大的便利。
本文针对既有稀疏矩阵并行算法库缺乏对多种矩阵存储格式及多核以及众核体系结构支持的问题，提出了面向众核体系结构的稀疏矩阵算法库，主要工作为：
1)  设计了面向众核体系结构的稀疏矩阵算法库的整体架构。利用层次化的思想将整 体架构分为数据层、计算层和用户层三层，使得稀疏矩阵算法库拥有更加优秀的易扩展、 低耦合、便于维护等特性。
2)  提出了稀疏矩阵的存储数据结构和格式转换机制。数据管理功能要求数据具有易 插入和易删除的特点，而计算管理功能要求数据具有易访存的特点。针对这两种不同的 需求，本文分别基于链表和数组设计了两种稀疏矩阵的存储数据结构。本文实现了一个 较为成熟的稀疏矩阵存储格式转换机制，支持不同的矩阵格式之间的双向转换。
3)  针对多核以及众核体系结构，使用特定的技术对并行算法进行结合体系结构的优 化。首先使用一个适用于多核以及众核体系结构的共性的优化方式，改造算法中的循环 使循环之间没有数据依赖。在此基础上，利用 OpenMP 技术动态设计线程数量优化多核 平台上的并行算法；利用循环合并和编译器自动向量化的方法优化 MIC 上的并行算法；利用 C+CUDA 的编程方法结合带状任务划分策略优化 GPU 上的并行算法。
4)  对面向众核体系结构的稀疏矩阵算法库在不同的体系结构下进行功能正确性及性能测试。测试结果表明，面向众核体系结构的稀疏矩阵算法库在不同平台上能够实现基本功能，拥有优良的可扩展性。与串行算法相比，稀疏矩阵算法库在不同的众核平台 上获得了很好的性能提升，其中在 GPU 上的加速比高达 26.92。

关键词：稀疏矩阵向量计算；众核技术；MIC；GPU









1. NoC总体设计：
我们可以在FPGA中模拟片上网络及其路由算法。
2D-mesh网络拓扑结构：
路由器架构：

系统的顶层模块是Network模块，Network模块包含若干个Router模块，每个Router模块中均包含   模块用于   、   模块用于   。
1.1. Network模块
如图2所示，我们可以在FPGA中模拟片上网络及其路由算法。基于二维网格 (2D-mesh)拓扑结构，定义结点(nodes)和路由器(routers)间的网络连接，即解决在结点和路由器、路由器和路由器之间，谁输出到谁，谁从谁输入的问题。在网络(Network)模块中，每个结点都拥有自己的路由器。每个结点只能与自己的路由器传输数据，而每个路由器则能和自己的上下左右四个方向的路由器传输数据，所以，每个路由器可定义5个端口(ports)。例如，在图2中，datain[i][0]/dataout[i][0]表示router[i]从node[i]接收的数据/router[i]输出到node[i]的数据，datain[i][1]/dataout[i][1]表示router[i]从其上方router接收的数据/router[i]输出到其上方router的数据，以此类推。

1.2. Router模块
在图3中，Router模块包含3个输入端口（i_en,i_data,i_data_val）和3个输出端口（o_en,o_data,o_data_val）。输入的数据先发送给FIFO模块，FIFO模块能在有数据输入而l_en为0（请求输出方向不允许输出）时，将输入数据进行缓冲，并在自身缓冲空间满时，向周围结点或路由器发送输出使能信号(o_en)。路由计算(Route Calculator)模块基于输入数据中的目的地信息，计算出数据请求的输出方向，并将请求发送给开关控制模块。开关控制(Switch Control)模块通过其它路由器发送来的输入使能信号（i_en）以及数据请求的输出方向，给FIFO模块下达是否可输出数据的信号（l_en），并给Switch模块发送输出请求应答信息。Switch模块根据应答信息，将FIFO发送来的数据发往相应的输出方向。
1.x. network模块
功能：
    路由网络基于2D-mesh拓扑结构，定义了PE结点和路由结点之间的网络连接。
    每个PE结点（nodes）都拥有一个路由器（routers），且PE结点只能和自己的路由器进行直接交流，而路由结点不仅可与PE结点进行通信，还可与符合条件的其它路由结点进行通信，因此，PE结点间只能通过路由结点进行通信。
    每个路由结点都有5个输入输出端口，其中一个端口链接PE结点，其余的端口链接周围的路由器。通过[结点号i][输入输出端口号j]结构表示第i个结点第j个端口的输入输出，其中j=0表示与PE结点链接的端口、j=1表示与北路由结点链接的端口、j=2表示与东路由结点链接的端口、j=3表示与南路由结点链接的端口、j=4表示与西路由结点链接的端口。
    2D-mesh拓扑结构的一个例子:
                                 12 13 14 15
                                 08 09 10 11
                                 04 05 06 07
                                 00 01 02 03

输入端口：
    logic clk, reset_n,
    packet_t [0:`NODES-1] i_data  // 从PE结点输入数据
    logic [0:`NODES-1] i_data_val  // 指出输入端口（i_data）有数据输入

输出端口：
    packet_t [0:`NODES-1] o_data  // 输出数据到PE结点
    logic [0:`NODES-1] o_data_val  // 指出输出端口（o_data）有数据输出
    logic [0:`NODES-1] o_en  // 输出 输入端口（i_data）的使能信号

1.x. router模块
功能：
    路由（router）模块拥有5个输入端口、5个输出端口，分别用于与PE结点、北路由结点、东路由结点、南路由结点、西路由结点链接。模块对应单个路由结点的完整架构，其中包括输入输出缓存（FIFO）模块、数据中间处理（agent）模块、路由计算(routing calculator)模块、选择策略（selection）模块、开关控制(switch control)模块、交换开关（switch one-hot packet）模块。

输入参数：
    integer X_LOC  // 当前结点的X坐标
    integer Y_LOC  // 当前结点的Y坐标

输入端口：
　　logic clk
　　logic reset_n
    packet_t [0:`N-1] i_data  // 输入的数据 [local, north, east, south, west]
    logic [0:`N-1] i_data_val  // 指出是否有数据输入 [local, north, east, south, west]
    logic [0:`N-1] i_en  // 输入 数据输出端口（o_data）使能 [local, north, east, south, west]

输出端口：
    packet_t [0:`M-1] o_data  // 需要输出的数据 [local, north, east, south, west]
    logic [0:`M-1] o_data_va  // 指出是否有数据需要输出 [local, north, east, south, west]
    logic [0:`M-1] o_en  // 输出 数据输入端口（i_data）使能 [local, north, east, south, west]
1.x. fifo_packet模块
功能：
    同步时序逻辑，使用存储阵列缓存由网络仿真框架生成特定的数据包类型。内存中每个单元都关联读和写两种指针，以控制内存的读写。每个指针用一位的二进制数表示，同一时刻读指针和写指针都只有一个能为高位。通过读、写请求，读写指针的高位在内存单元间轮转，使得同一时刻只有一个单元可读和一个可写。并向上游路由结点发送缓存是否已满的信号。

输入参数：
    DEPTH = `INPUT_QUEUE_DEPTH // 缓存队列深度

输入端口：
    logic clk  // 时钟信号
    logic ce  // 使能信号
    logic reset_n  // 复位信号
    packet_t i_data  // 输入需存入FIFO的packet_t结构的数据
    logic i_data_val  // 指出i_data端口是否有数据输入，当i_data_val=1时，表示有数据输入
    logic i_en  // 输入 数据输出端口（i_data） 的使能信号，控制数据的输出，当一个时钟上升沿来临时，若使能信号为高，则允许数据输出

输出端口：
    packet_t o_data  // 输出需从FIFO发送的packet_t结构的数据
    logic o_data_val  // 指出是否有数据要从o_data端口输出，当o_data_val=1时，表示有数据输出 Validates the data on o_data, held high until input enable received
    logic o_en  // 输出 数据输入端口（i_data） 的使能信号，表示缓存队列是否有空闲，若使能信号为高，则表示输入的数据可以被写入内存 Outputs an enable, if high, i_data is written to memory
1.x. ant_agent模块
功能：
    对需要输出的数据进行必要的处理和路由计算，并将处理后的数据发送给交换开关（switch one hot）模块，将路由计算后得到的输出请求发送给交换控制（switch control）模块。

输入参数：
    integer X_LOC // 当前结点的X坐标
　　integer Y_LOC // 当前结点的Y坐标

输入端口：
    logic reset_n // 复位信号
    packet_t [0:`N-1] i_data // 数据输入端口
    logic [0:`N-1] i_data_val // 指出是否有数据输入

输出端口：
    packet_t [0:`M-1] o_data // 数据输出端口，输出给switch one hot
    logic [0:`N-1] o_data_val // 指出是否有数据输出，输出给switch one hot
　　logic [0:`N-1][0:`M-1] o_output_req //N个输入端口的对输出端口的请求情况，输出给switch control
1.x. routing模块
功能：
    通过路由算法，计算出可选择的输出端口队列。路由算法可包括X-Y路由、奇偶转弯模型路由（odd even turn model routing）等，根据具体的路由算法进行路由计算时需要的具体信息条件可再创建更多的输入端口以输入需要的信息。

输入参数：
    integer X_LOC  // 当前结点的X坐标
    integer Y_LOC  // 当前结点的Y坐标

输入端口：
    logic [0:`N-1] i_routing_calculate  // 路由计算使能信号
    logic [0:`N-1][$clog2(`X_NODES)-1:0] i_x_dest  // 输入数据包目的地的x坐标
    logic [0:`N-1][$clog2(`Y_NODES)-1:0] i_y_dest  // 输入数据包目的地的y坐标

输出端口：
    logic [0:`N-1] o_select_neighbor  // 输出选择使能信号
    logic [0:`N-1][0:`M-1][1:0] o_avail_directions  //输出可选择的输出端口队列
1.x. selection模块
功能：
　　通过选择策略，在可选择的输出端口队列中选择一最终（最优）输出端口。

输入参数：
    integer X_LOC  // 当前结点的X坐标
    integer Y_LOC  // 当前结点的Y坐标

输入端口：
    logic reset_n  // 复位信号
    logic [0:`N-1] i_select_neighbor  // 进行输出端口选择的使能信号
    logic [0:`N-1][0:`M-1][1:0] i_avail_directions  // 可选择的输出端口队列
    logic [0:`N-1][$clog2(`X_NODES)-1:0] i_x_dest  // 输入数据包的目的地的x坐标
    logic [0:`N-1][$clog2(`Y_NODES)-1:0] i_y_dest  // 输入数据包的目的地的y坐标

输出端口：
    logic [0:`N-1][0:`M-1] o_output_req  // 通过选择策略分别得到的对应N个输入数据请求的输出端口
1.x. switch_control模块
功能：
    交换控制。分配输入输出信道？分配交换机？

输入端口：
    logic clk //时钟信号
    logic ce //使能信号
    logic reset_n //复位信号
    logic [0:`M-1] i_en // 从下游路由结点发来的信号，指出对应的下游路由结点是否可用（有空闲）
　　logic [0:`N-1][0:`M-1] i_output_req // N个本地的输入单元对M个输出端口的请求情况
　　
输出端口：
    logic [0:`M-1][0:`N-1] o_output_grant // M个输出端口分别对N个输入端口的请求作出的应答，输出给switch onehot packet模块
    logic [0:`N-1] o_input_grant // 对N个输入缓存队列的应答信号，输出给agent模块
1.x. switch_onehot_packet模块
功能：
　　N x M 交换开关。
　　N个输入端口，M个输出端口。每个输出端口分别对应一个N位的二进制数，N位分别对应N个输入端口。输入端口的选择过程采用one-hot编码，即一位二进制数对应一个输入端口，且同一时刻最多只允许一位为1。输出端口根据自己对应的N位one-hot编码选择一个输入端口。
    // 5位one-hot编码对应的请求输出端口[local, north, east, south, west]
    //     1
    //   4 0 2
    //     3

输入端口：
    logic [0:`M-1][0:`N-1] i_sel  // M个N位one-hot编码
　　packet_t [0:`N-1] i_data    // N个数据输入端口
　　
输出端口：
    packet_t [0:`M-1] o_data   // M个数据输出端口


1.3. Route Calculator模块
　　always_comb begin
　　    o_output_req = '0;
　　    if(i_val) begin
　　      //i_x_dest：数据包的目的地地址的x坐标；X_LOC：当前路由结点x坐标。
　　      //若i_x_dest不等于X_LOC，则继续沿X维方向传送。
　　      //若i_x_dest等于X_LOC，则进入下一个if语句。
　　      if(i_x_dest != X_LOC) 
　　        o_output_req = (i_x_dest > X_LOC) ? 5'b00100 : 5'b00001;
　　      //i_y_dest：数据包的目的地地址的x坐标；Y_LOC：当前路由结点y坐标。
　　      //若i_y_dest还未等于Y_LOC，则继续沿Y维方向传送。
　　      //若i_y_dest等于Y_LOC，则表明此时到达目的地。
　　      else if (i_y_dest != Y_LOC)
　　        o_output_req = (i_y_dest > Y_LOC) ? 5'b01000 : 5'b00010;
　　      else
　　        o_output_req = 5'b10000;//此为到达目的路由时，向结点传送数据。
　　    end
　　end
　　　算法1 基于SystemVerilog的X-Y路由算法

算法1描述了X-Y路由算法的基本过程。在X-Y路由中，消息逐维遍历网络，在切换到下一维度前，需先沿X维到达吻合目的地坐标的Y维。即发送的数据包，首先沿着x维传送，其次再沿着y维传送。比如一个要从坐标(0,0)发送到坐标(2,3)的数据包，将首先沿着x维遍历2跳数，到达坐标(2,0)，然后才沿Y维遍历3跳数到达其目的地。由于上述X-Y路由的实现未考虑当前网络状态，通过加入必要的网络状态监控代码和与其相关的路径选择等代码，可实现基于蚁群优化的自适应路由算法。
ACO算法需在每个路由器模块加入AntNetAgent、Pheromone和AntPacket定义。AntPacket是为实现蚁群算法所添加的新数据包结构，可分为forward ant packet和backward ant packet两种类型，前一类型标志当前数据是由源结点发往目的结点，后一类型标志当前数据是由目的结点返回源结点；Pheromone类记录当前路由器周围4个路由的状态；AntNetAgent模块负责在路由器发送、接收AntPacket时对其进行额外处理，并在backward ant packet数据类型经过时增加Pheromone类里相应数据的数值以及隔一定周期减少Pheromone类里数据的数值。



×路由算法：
  ××维序路由
  ××无关路由
  ××自适应路由算法（Routing4.5）【重点】
    一种更复杂的路由算法是可以自适应的，即一个消息可以根据网络流量情况选择从A到B的路径。
    本地或全局信息可以被利用来进行自适应路由的决策。自适应路由算法往往依赖于本地路由器信息，比如队列占用和排队延迟等信息，来衡量交通拥堵并选择链接。
    ×××奇偶转弯模型路由（Routing4.5.1）【如果被应用了就是大重点】
       奇偶转弯模型路由[39]提出了是否消除一组两个的转弯将根据取决于当前节点是在奇数列还是偶数列。例如，当一个数据包经过一个在偶数列的节点时，由东转向北和由北转向西的转弯被禁止。由于这种的限制，奇偶转弯模型通过禁止180°转弯（？）达到了无死锁。奇偶转弯模型比其他转弯模型算法如西向优先算法提供了更好的自适应性。使用西向优先算法，若从在目的地西向的源地址出发，就没有了灵活性；使用奇偶路由，就可以灵活性地根据给定的列所允许的转弯。

    ×××4个方向4种优先转弯（from me乱想的）：
       d.x>s.x(c.x):west-first;
       d.x<s.x(c.x):east-first;
       d.x=s.x(c.x):
                    d.y>s.y(c.y):south-first;
                    d.y<s.y(c.y):north-first;

*选择策略：
  ××random
  ××DBL
  ××ACO【大重点】

×实现：基于结点表格（Routing4.6.2）
    在每一跳使用路由表存储一个数据包应该采取的到达特定目的地的输出链接。通过在每一跳访问路由信息（而不是都在源结点访问），不仅可以实现自适应算法，还可以利用每一跳的网络拥塞信息来做出决策。




【实验结果分析】
×输入：
  ××均匀的：
    1、路由算法：X-Y路由
    2、路由算法：奇偶转弯模型路由
       选择策略：①random；②DBL；③ACO
     
  ××非均匀的：
    ×××规则热点：
       1、路由算法：X-Y路由
       2、路由算法：奇偶转弯模型路由
          选择策略：①random；②DBL；③ACO
    ×××非规则热点：
       1、路由算法：X-Y路由
       2、路由算法：奇偶转弯模型路由
          选择策略：①random；②DBL；③ACO

2.4 No C 路由算法性能参数 
    设计路由算法不仅仅是简单的能够运用，还要兼顾网络性能、死锁、拥塞等各个方面。在NoC路由算法的研究中，衡量NoC的网络性能至关重要，现在对其要求也更加精准、全面。因此本文从以下几个性能参数进行分析。 
（1）网络平均吞吐率（Throughput）是指每个周期内网络的每个节点平均可以发送或接收的数据量，其取决于路由、仲裁和网络拓扑[24]。
 
Throughput =    

 
网络吞吐率关系着网络是否发生拥塞现象，数据包传输时路由算法能够合理的分配路
径资源，这样能够缩短网络的传输时延。 
（2）网络时延是数据包从源节点到目标节点所要消耗的时间代价，这不仅仅与网络
路由结构、仲裁和网络拓扑，也与路由算法的优劣有关。网络时延可以分为三部分组成：
发送时延、传输时延与接收时延[24]。 
发送时延 sl 是指路由节点对数据进行传输时在路由节点内部消耗的时间代价。 
传输时延 wl 是指数据包在网络路径传输时消耗的时间，即从源节点到目标节点在路径所用的时间。 
接收时延 rl 指当数据包到达目标节点时，目标节点接收数据路由节点内部所消耗的时间。 
   
Latency = sl + wl + rl

其中传输时延是网络时延的主要时延。因此在路由设计时，要着重分析传输时延，进行降低网络时延。 


【在一个clk内，若每个组合逻辑的各部分都最多只会得到一次激励，则可以确定结果不会被覆盖。对本电路：要保证一个周期内可完成电路过程。】